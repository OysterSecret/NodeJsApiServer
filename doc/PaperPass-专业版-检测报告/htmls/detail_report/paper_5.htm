<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：5/8页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">135</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.授权码模式（authorization code）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">136</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.简化模式（implicit）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">137</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.密码模式（resource owner password credentials）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">138</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.客户端模式（client credentials）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">139</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/392/392.htm' target='right' class='orange' >Passport认为每个应用程序都有独特的身份验证需求。</a><a href='../sentence_detail/393/393.htm' target='right' class='orange' >通过身份验证机制，也被称为策略，Passport将其打包为单个模块。</a><span class='green'>应用程序可以选择使用哪种策略，而不需要创建不必要的依赖关系。</span><span class='green'>尽管在身份验证中涉及到复杂的问题，但代码并不一定要复杂。</span><span class='green'>因此通过模块的封装，基于Passport可以很方便的实现登录验证过程以及需要的OAuth2.0授权方式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">140</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2.1用户登录认证</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">141</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>用户账号密码登录是每个服务器需要实现的基本功能之一，对于一个服务器而言，用户信息是其最基本最重要的数据信息，</span><a href='../sentence_detail/399/399.htm' target='right' class='orange' >服务器需要通过用户登录过程，验证用户是否是合法的已注册用户，具备何种的权限。</a><span class='green'>并且所有以用户用户名作为外键的表都需要先经过登录过程，才能完成业务的正常进行。</span><span class='green'>在登录成功后，因为 HTTP是无状态的协议，即这个协议是无法记录用户访问状态的，其每次请求都是独立的无关联的，</span><span class='green'>而服务器需要知道用户的状态信息，尤其是登录状态信息，因此服务器需要将该用户信息记录到请求的 Cookie中标记登录状态，</span><a href='../sentence_detail/403/403.htm' target='right' class='orange' >再为该用户的登录会话创建 Session记录服务器的用户信息。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">142</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>基于Passport的用户登录模式是加入passport-local的模块，而后在代码中编写本地的用户密码授权策略，便可以接受local模式的认证请求，具体代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">143</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/405/405.htm' target='right' class='orange' >其中，使用 Redis数据库查询 HTTP请求中的用户名，检查 HTTP请求中密码经过 MD5加盐后的散列值是否与数据库中存储的散列值一样，</a><span class='green'>如果是的话则认证成功。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">144</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>而后在Node.js的Express框架中，编写登录与注销的Post请求路由路径，如下所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">145</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中登录通过调用passport的authenticate命令，查询local策略，调用上述的local登录策略代码，成功或失败后复位向到相应的链接完成登录。</span><a href='../sentence_detail/409/409.htm' target='right' class='orange' >注销通过在request中清除用户的Cookie信息，完成注销过程。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">146</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2.2授权码模式授权</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">147</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在授权码模式授权的作用是为处理服务器提供一个公共的授权接口，提供给不可信任的第三方客户端使用，从而避免第三方应用获取用户的账户密码信息。</span><a href='../sentence_detail/412/412.htm' target='right' class='orange' >在授权码模式流程中，客户端不会直接向资源服务器请求 Token授权，而是把资源服务器导向 Auth服务器要求许可，</a><a href='../sentence_detail/413/413.htm' target='right' class='orange' > Auth服务器再通过 Redirect URI转址来告诉客户端授权许可码（ code）。</a><a href='../sentence_detail/414/414.htm' target='right' class='orange' >在复位向回去之前，Auth服务器会先认证资源服务器并取得权限。</a><a href='../sentence_detail/415/415.htm' target='right' class='orange' >因为资源服务器只跟Auth服务器认证所以客户端便绝对无法拿到用户的帐号密码。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">148</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在这种流程中授权码会以一个散列的字符串存储在服务器数据库，然后转发给客户端。</span><span class='green'>作为授权的许可条件。</span><span class='green'>在获取授权码之后。</span><span class='green'>此时是仍然没有获取Access Token的，客户端需要自己将授权码发送给Auth服务器请求Access Token的授权。</span><span class='green'>整个的流程具体如下图4-2所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">149</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（A）客户端把用户的 User-Agent转发到Auth服务器启动流程。</span><span class='green'>客户端会传输Client ID， 申请的 scopes，内部 state，Redirection URI作为转址地址接受Auth服务器授权结果。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">150</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/423/423.htm' target='right' class='orange' >（B）Auth服务器通过 User-Agent验证用户是否合法，并确认资源拥有者许可或者驳回客户端的授权请求;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">151</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（C）假设资源拥有者许可了授权请求，Auth服务器会把User-Agent 复位向回先前指定的Redirection URI其中包含了：</span><span class='green'>Authorization Code，许可的 scopes，先前提供的内部 state;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">152</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（D）Client向Auth服务器发送Token请求，传送时附带：</span><span class='green'>先前取得的 Authorization Code以及Client的认证资料</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">153</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（E）Auth服务器认证Client与Authorization Code，符合的话回传随机生成的散列Access Token与Refresh Token。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">154</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2.3密码模式授权</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">155</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>密码模式授权通常用于可信任的客户端授权，由于授权码模式授权需要经过一个授权码中转流程较为繁琐，而对于服务器可以信任的客户端请求，</span><span class='green'>如同一公司开发的或者经过认证的客户端，则可以通过密码模式授权简化流程。</span><span class='green'>在密码模式授权流程中，用户自身的帐号密码以及可信客户端的 Client信息将直接当作授权许可，</span><span class='green'>传输给 Auth服务器获取 Access Token，这种模式要求客户端开发过程中禁止存储用户的帐号密码，只在授权时使用一次，</span><span class='green'>用来获取 Access Token，随后存储长效的 Access Token或 Refresh Token用以认证，最后拿到的除了 Access Token之外，</span><span class='green'>还会拿到 Refresh Token，整个授权的流程图如下图4-3所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">156</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-3 密码模式授权流程图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">157</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/437/437.htm' target='right' class='red' >（A）用户向客户端提供真正的帐号密码；</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">158</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/438/438.htm' target='right' class='orange' >（B）客户端使用客户的帐号密码与自身的Client信息，向Auth服务器申请Access Token认证;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">159</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/439/439.htm' target='right' class='orange' >（C）Auth服务器认证Client信息与用户的帐号密码后，如果正确则核发Access Token给客户端</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">160</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2.4 Refresh Token换发授权</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">161</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>换发( Refreshing) Access Token，指的是处于安全考虑， Access Token存在于一个 expire时限，</span><span class='green'>超过时将会失去认证效应，导致目前的 Access Token过期或者权限不足，而需要取得新的 Token。</span><span class='green'>允许换发的前提是 Auth服务器之前有向客户端许可过Refresh Token。</span><span class='green'>如果没有的话则不行。</span><span class='green'>Client通过捕获Response的502状态码 Unauthorized异常，自动完成换发Access Token。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">162</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/446/446.htm' target='right' class='orange' >Refresh Token通常具备较长的有效期，被用作获取新的Access Token，因此客户端需要存储Refresh Token在本地。</a><span class='green'>在换发新的Access Token的时候，可以一起授权新的 Refresh Token，而后客户端将新的Refresh Token替换旧的Refresh Token，这样子的话客户端必须把旧的Refresh Token。</span><span class='green'>同时，Auth服务器也许要删除旧的Refresh Token。</span><span class='green'>新的Refresh Token其Scope也要与旧的保持一致。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">163</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2.4 Bearer Token认证</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">164</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>OAuth 2.0 (RFC 6749)定义了客户端如何获取Access Token的方法，通过Access Token获取Protected Resource。</span><span class='green'>OAuth 2.0定义Access Token是资源服务器用来认证的唯一方式，基于Token的验证方式资源服务器就不需要再提供其他认证方式，例如用户的账号密码。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">165</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>然而在 RFC 6749里面只定义了抽象的概念，细节如Access Token的格式，如何传输给资源服务器以及无效的处理方法都没有进行定义，所以在RFC 6750标准中定义了Bearer Token的概念与用法。</span><span class='green'>所以在 RFC 6750 另外定义了 Bearer Token 的用法。</span><span class='green'>Bearer Token是一种 Access Token的类型，由 Auth服务器在资源拥有者允许下核发给客户端，</span><a href='../sentence_detail/456/456.htm' target='right' class='orange' >资源服务器只要认证 Token合法就可以认定客户端已经由资源拥有者许可，</a><span class='green'>不需要再通过密码来验证 Token的真伪。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">166</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Bearer Token的格式为Bearer XXXXXXXX，其中 XXXXXXXX 的格式为 b64token，b64token的定义：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">167</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>b64token = 1*( ALPHA / DIGIT / ”-” / ”.” / ”_” / ”~” / ”+” / ”/” ) *”=”</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">168</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>写成 Regular Expression 即是：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">169</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>/[A-Za-z0-9\-\._~\+\/]+=*/</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">170</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/462/462.htm' target='right' class='orange' >客户端向资源服务器校验Access Token的方式有三种：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">171</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>(1) 放在HTTP Header里面，Header键规定为Authorization，值规定为Bearer加上Token实际值，Auth服务器必须支持这种方式，也是最为安全的方式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">172</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>(2) 放在Request Body里面（Form之类的），以键值对发送，前提是Header 要有 Content-Type:</span><span class='green'>application/ x- www- form- urlencoded， Body格式要符合 W3 C HTML4.01定义 application/ x- www- form- urlencoded，</span><span class='green'>Body要只有一个 part（不可以是 multipart）， Body要编码成只有 ASCII chars的内容， Request method必须是一种有使用 request- body的，</span><span class='green'>也就是说不能用 GET。</span><span class='green'>Auth服务器可以但不一定要支持这个方式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">173</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>(3) 放在 URI 里面的一个 Query Parameter，这种方式由于完全将Token暴露出来，因此是不建议的方式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">174</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Auth服务器向客户端返回认证失败的情况，例如没给 Access Token或是给了但不合法（如空号、过期、资源拥有者没许可客户端拿取此资料），</span><span class='green'>则 Auth服务器必须在回应里包含 WWW- Authenticate的 header来提示错误。</span><span class='green'>这个 header 定义在 RFC 2617 Section 3.2.1。</span><span class='green'>WWW-Authenticate 的值，使用的auth-scheme 是 Bearer ，随后一个空格，接着要有至少一个auth-param。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">175</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>如果客户端出示了 Access Token 但认证失败，则最好加上 error 这个 auth-param ，用来告诉客户为何认证失败。</span><span class='green'>此外还可以加上 error_description 用自然语言来告诉开发者为什么错误，但这个不该给使用者看到。</span><span class='green'>此外也可以加上 error_uri 用来提供一个网址，里面用自然语言解释错误讯息。</span><span class='green'>这三个auth-param 都只能最多出现一次。</span><span class='green'>如果客户端没有出示 Access Token （例如客户端不知道需要认证，或是使用了不支持的认证方式（例如不支持 URI parameter）），则 response 不应该带 error 或任何错误讯息。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">176</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.3 Restful API接口实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">177</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/480/480.htm' target='right' class='orange' >Restful(REST)或RESTful Web服务是在Internet上提供计算机系统互操作性的一种方式。</a><a href='../sentence_detail/481/481.htm' target='right' class='orange' >符合rest风格的Web服务允许使用一套统一标准表示对系统访问和操作的请求，并且预定义Web资源的操作是无状态的。</a><span class='green'>其他形式的Web服务标准，会暴露本身的一系列操作，如WSDL和SOAP[1]。</span><span class='green'>2000年，Roy Fielding在他的博士论文中提出了“表征状态”的概念[2][3]。</span><span class='green'>使用REST来设计HTTP 1.1和统一资源标识符(URI)[4][5][6]。</span><span class='green'>Rest这个概念是为了传达如何设计一个良好的Web应用程序行为：</span><span class='green'>它是一个网络中的网络资源（或者虚拟状态机），用户在应用程序中通过选择要访问链接，</span><span class='green'>如/ user/ tom，来进行 GET或 DELETE等操作(状态转换)，并将下一个资源(代表应用程序的下一个状态)传输给用户使用。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：5/8页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
