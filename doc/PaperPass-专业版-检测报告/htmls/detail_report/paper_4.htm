<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：4/8页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">105</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>同时对createTime字段创建索引，MongoDB索引方式与传统RDBMS一样采用B+树的索引方式，因此使用方法与RDBMS类似。</span><span class='green'>MongoDB支持单字段索引，复合字段索引以及数组索引的方式，我们通过ensureIndex({createTime:</span><span class='green'>-1})命令，为CreateTime字段创建倒序的单字段索引。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">106</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.3Redis数据库</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">107</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>redis是一个key-value存储系统。</span><span class='green'>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset--有序集合)和hash（哈希类型）。</span><a href='../sentence_detail/293/293.htm' target='right' class='red' >这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</a><span class='green'>在此基础上，redis支持各种不同方式的排序。</span><a href='../sentence_detail/295/295.htm' target='right' class='red' >与memcached一样，为了保证效率，数据都是缓存在内存中。</a><a href='../sentence_detail/296/296.htm' target='right' class='red' >区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">108</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis是一个高性能的key-value数据库。</span><a href='../sentence_detail/298/298.htm' target='right' class='red' >redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。</a><span class='green'>它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。</span><span class='green'>[1]</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">109</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis支持主从同步。</span><a href='../sentence_detail/302/302.htm' target='right' class='red' >数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。</a><span class='green'>这使得Redis可执行单层树复制。</span><a href='../sentence_detail/304/304.htm' target='right' class='red' >从盘可以有意无意的对数据进行写操作。</a><a href='../sentence_detail/305/305.htm' target='right' class='red' >由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。</a><a href='../sentence_detail/306/306.htm' target='right' class='red' >同步对读取操作的可扩展性和数据冗余很有帮助。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">110</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.3.1 缓存Session</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">111</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/308/308.htm' target='right' class='red' >Session 是面向连接的状态信息，是对 Http 无状态协议的补充。</a><a href='../sentence_detail/309/309.htm' target='right' class='red' > Session数据保留在服务端，而为了标识具体 Session信息指向哪个连接，需要客户端传递向服务端发送一个连接标识，</a><a href='../sentence_detail/310/310.htm' target='right' class='red' >比如存在 Cookies中的 session_ id值（也可以通过 URL的 QueryString传递），服务端根据这个 id存取状态信息。</a><a href='../sentence_detail/311/311.htm' target='right' class='red' >随着网站规模（访问量/复杂度/数据量）的扩容，针对单机的方案将成为性能的瓶颈，分布式应用在所难免。</a><span class='green'>所以，有必要研究一下 Session 的分布式存储。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">112</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/313/313.htm' target='right' class='red' >如前述， Session使用的标识其实是客户端传递的 session_id，在分布式方案中，一般会针对这个值进行哈希，以确定其在 hashing ring 的存储位置。</a><a href='../sentence_detail/314/314.htm' target='right' class='red' >hashing ring就是一个分布式结点的回路（取值范围：</a><span class='green'>0到232-1，在在零点重合）：</span><a href='../sentence_detail/316/316.htm' target='right' class='red' >Session 应用场景中，它根据 session_id 的哈希值，按顺时针方向就近安排一个小于其值的结点进行存储。</a><a href='../sentence_detail/317/317.htm' target='right' class='red' >在 Session 处理的事务中，最重要的环节莫过于 客户端与服务端 关于 session 标识的传递过程：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">113</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/318/318.htm' target='right' class='red' >1、服务端查询客户端Cookies 中是否存在 session_id</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">114</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2、有session_id，是否过期？</span><span class='green'>过期了需要重新生成；</span><span class='green'>没有过期则延长过期</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">115</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3、没有 session_id，生成一个，并写入客户端的 Set-Cookie 的 Header，这样下一次客户端发起请求时，就会在 Request Header 的 Cookies带着这个session_id。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">116</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在Node.js中，通过Express Session模块，以及Redis的connect-redis模块，可以方便的搭建基于Redis的分布式缓存，node.js实现代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">117</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.3.2 缓存查询</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">118</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于水厂处理系统服务端而言，绝大多数的查询都是对实时数据与最近历史数据的查询，因此我们可以通过Redis构建查询缓存，降低数据库访问压力，加快请求处理相应。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">119</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis支持 String， List， Set， Hash类型的数据存储格式，对于水质处理流程模型的查询结果，我们可以选用 List格式进行存储，</span><span class='green'>由于大部分查询都是根据 createTime倒序排序查询一定数量的数据，因此我们可以用 collectionName的键存储缓存结果，</span><span class='green'>当有新的数据插入时，通过 lpush( key， String)的方式往该 collectionName的 list插入更新数据的 Json字符串，</span><span class='green'>然后使用 rpop( key)命令将所有尾部元素删除。</span><span class='green'>在查询时，如果查询的排序方式是倒序排序 createTime，首先判断查询请求的 limit是否超过 list缓存的长度，</span><span class='green'>可以通过 llen( key)命令查询，如果小于则直接通过 lrange( key， skip， limit)命令直接从 Redis中取出，</span><span class='green'>否则话，先判断当前节点的可用内存大小，然后判断新的 limit是否足够，足够的话，</span><span class='green'>从 MongoDB中查询数据，然后更新到 List中。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">120</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于用户请问访问时，都需要先获得 Token的授权，然后每次请求需要经过 Token的验证，</span><span class='green'>因此直接使用 MongoDB存储 User与 Token，需要每次请求前额外访问一次数据库查询，而 User与 Token表通常数据量不大，</span><span class='green'>因此可以将整个表预先从 MongoDB存入 Redis作缓存查询。</span><span class='green'>Redis不支持直接存储Object对象，但是可以通过Hash数据结构存储Object。</span><span class='green'>通过命令hmset(key， Object)命令，将一个Object对象存入Redis，其中key是数据表名加上数据主键，然后可以通过hgetall(key)命令查询需要的数据。</span><span class='green'>对于无法直接根据主键搜索的数据，需要额外的用set(key， String)命令建立需要搜索的key与主键的关联，然后再进去查询。</span><span class='green'>当需要删除该Object时，使用hdel(key， fields)命令来删除所有Hash值。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">121</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>四章 处理服务器实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">122</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.1语言与框架</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">123</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>传统的企业服务器通常采用 JAVA语言，基于 Spring， Spring MVC， Mybaits三大框架实现对 HTTP请求的处理与响应，</span><span class='green'>其中 JAVA是一种面向对象的强类型语言，然而由于 JAVA处理异步任务只有通过新的线程或者线程池实现，</span><span class='green'>缺乏 await语义，因此总有线程因为 IO或者其他原因处在 sleep状态，其结果就是没办法（很难）实现单服务器高并发的承载能力，</span><span class='green'>并且 SSM框架仍然是基于传统的 SOA思想设计，对于分布式系统的实现十分复杂，对 Restful API的支持仍有许多局限。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">124</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/347/347.htm' target='right' class='red' >为了能适应高并发的情况（成千上万的连接），服务器需要采用异步非阻塞模式。</a><a href='../sentence_detail/348/348.htm' target='right' class='red' >可能已经在IO操作中实现了这种方式。</a><a href='../sentence_detail/349/349.htm' target='right' class='red' >但问题是，如果服务器代码的任何部分可能产生阻塞，你都需要开启一个线程。</a><a href='../sentence_detail/350/350.htm' target='right' class='red' >在这种级别的并发下，你不能去为每个连接创建线程。</a><a href='../sentence_detail/351/351.htm' target='right' class='red' >所以整个代码路径都需要异步非阻塞式的， 不仅仅在输入输出层。</a><span class='green'>这就是 Node擅长的地方，以下图4-1是 JAVA这类多线程服务器与 Node. js的对比，因此对于一个并发数巨大但是业务逻辑基本较为简单的企业应用，</span><span class='green'>Node. js是一个快速实现处理服务器的最佳选择之一。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">125</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/354/354.htm' target='right' class='orange' >图4-1 多线程服务器与Node.js服务器对比图</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">126</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/355/355.htm' target='right' class='orange' > Node. js是基于弱类型的解释性脚本语言 JavaScript实现的可以快速构建网络服务及应用的平台，</a><a href='../sentence_detail/356/356.htm' target='right' class='red' >在 Chrome JavaScript V8 Runtime建立的平台，用于方便地搭建响应速度快、易于扩展的网络应用。</a><a href='../sentence_detail/357/357.htm' target='right' class='red' >Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。</a><a href='../sentence_detail/358/358.htm' target='right' class='red' >V8引擎执行Javascript的速度非常快，性能非常好。</a><a href='../sentence_detail/359/359.htm' target='right' class='red' >Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">127</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/360/360.htm' target='right' class='red' >Node.js使用Module模块去划分不同的功能，以简化应用的开发。</a><a href='../sentence_detail/361/361.htm' target='right' class='red' >Modules模块有点象C语言中的类库。</a><a href='../sentence_detail/362/362.htm' target='right' class='red' >每一个 Node. js的类库都包含了十分丰富的各类函数，比如 http模块就包含了和 http功能相关的很多函数，</a><a href='../sentence_detail/363/363.htm' target='right' class='red' >可以帮助开发者很容易地对比如 http， tcp/ udp等进行操作，还可以很容易的创建 http和 tcp/ udp的服务器。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">128</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>NPM是 JavaScript的包管理器，也是世界上最大的软件仓库，用户通过 NPM来安装，分享与发布代码模块，</span><span class='green'>Node. js通过编写 package. json文件构建模块依赖，然后通过 npm install命令一键执行安装文件中的所有模块。</span><span class='green'>对于水质处理工厂服务端，我们创建package.json文件并加入如表4-1所示的依赖模块：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">129</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>作用模块名备注</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">130</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>基于以上模块，我们运行npm install便可构建处理服务器的基本框架，通过require命令在JavaScript代码中编写处理服务器的具体代码。</span><span class='green'>在以下章节将介绍处理服务器的具体实现，主要包括授权与验证，Restful Api接口。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">131</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2 授权与验证</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">132</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于任何的服务端而言，安全往往是容易受到忽视的一个重要部分，许多早期的公司由于为了方便接口完全暴露在公网，因此成为了黑客与爬虫的目标，被窃取大量机密的公司业务数据，造成了大量的损失。</span><span class='green'>因此业界一直也在研究有关服务器授权与验证的问题。</span><span class='green'>如何验证请求的合法性，保障接口与数据的安全，是开发处理服务器的首要目标。</span><span class='green'>对于服务器而言，授权与验证过程既要保证安全性，同时也要满足高效性，避免大量服务器计算性能消耗在授权与验证过程中，造成了请求过高的延迟。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">133</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于Node.js平台，Passport库是实现多种不同方式授权与验证的很好选择。</span><span class='green'>Passport是一个Node的身份认证中间件，它被设计用于服务端请求认证的目的。</span><span class='green'>当编写模块时，封装是一种优点，因此Passport将所有其他功能委托给应用程序。</span><span class='green'>这种原则可以隔离代码依赖，使其保持整洁和具备可维护性，并且使Passport非常容易集成到应用程序中。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">134</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/379/379.htm' target='right' class='orange' >在现代web应用程序中，身份验证可以采用多种形式。</a><a href='../sentence_detail/380/380.htm' target='right' class='orange' >传统中用户通过提供用户名和密码登录服务器。</a><span class='green'>随着社交网络的兴起，使用OAuth提供商(例如Facebook或Twitter)单点登录已经成为一个受欢迎的身份验证方法，而公开API的服务通常也需要基于Token的凭证来保护访问。</span><a href='../sentence_detail/382/382.htm' target='right' class='red' >其中OAuth是一种认证与授权的协议，OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。</a><a href='../sentence_detail/383/383.htm' target='right' class='red' >”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。</a><a href='../sentence_detail/384/384.htm' target='right' class='red' >”客户端”登录授权层所用的令牌（token），与用户的密码不同。</a><a href='../sentence_detail/385/385.htm' target='right' class='red' >用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</a><a href='../sentence_detail/386/386.htm' target='right' class='red' >”客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</a><span class='green'>OAuth 2.0定义了四种授权方式。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：4/8页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
