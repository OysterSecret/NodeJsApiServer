<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_6.htm">上一页</a>
<a class="pagelink" href="paper_8.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：7/8页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">214</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于多台物理主机而言，首先需要通过Docker Swarm为所有物理主机搭建集群环境建立通信以进行管理，搭建集群的方法是：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">215</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1、选取任意一台（建议采用性能最佳）的主机作为集群的 Manager，首选获取该台主机的 IP地址，</span><span class='green'>然后在任意一台具备 Docker Swarm的主机上使用 docker swarm init-- advertise- addr[ MANAGER- IP]命令建立集群;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">216</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2、输入docker swarm join-token worker获取其他主机加入该Manager集群网络的命令;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">217</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3、 输入docker swarm join --token SWMTKN-1-[TOKEN] [MANAGER-IP]与Manager建立TLS安全通信，则完成了将该台物理主机加入集群中。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">218</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中建立TLS安全通信的原因是为了避免中间人伪造Docker通信的数据包从而启动一些外部的不安全容器造成中间人攻击。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">219</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在将所有的物理或虚拟主机都加入集群中后，先使用 docker node list命令，查询当前集群中所有节点的数量，</span><span class='green'>然后使用 docker stack deploy– compose- file docker- compose. yml命令，启动 Docker Compose文件所编排的所有容器，</span><span class='green'>自动地均衡启动在集群中的节点中，再使用 docker stack services命令查询处理服务器的 Service名字，最后使用 docker service scale[ SERVICE- NAME]=[ NODE- AMOUNT]命令，</span><span class='green'>将处理服务器自动地扩增到集群中的每台节点中启动，并在启动时通过 PM2启动多进程的 node. js实例绑定到每台主机的 CPU上，</span><a href='../sentence_detail/593/593.htm' target='right' class='orange' >至此完成了处理服务器的部署，并最大限度的利用了集群的计算性能。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">220</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>当集群的性能出现瓶颈，已经无法支撑用户的访问，需要增加新的主机时，在新的主机中运行以下脚本，</span><span class='green'>便可以在集群运行中的任意时刻将一台主机加入集群中并自动地部署处理服务器：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">221</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1.3服务发现与均衡负载器配置</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">222</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于Consul服务发现的配置，通过在Docker Compose配置文件中编写Consul与Registrator两个容器的编排：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">223</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中consul容器使用官方最新版本的consul-server镜像，通过--bootstrap命令自动启动，并暴露8500一个HTTP端口来与外部的容器通信。</span><span class='green'>registrator容器使用同一开发者的 registrator容器镜像，并添加对consul容器的链接，然后通过命令-internal -resync 600 consul:</span><span class='green'>//consul:</span><span class='green'>8500使得自己每隔600毫秒向consul server同步监听到的当前集群内所有Docker容器以及它们的IP地址与端口，VOLUMES挂载的目的是为了在registrator容器中获取Docker的所有容器列表。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">224</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后编排好的容器会在docker stack deploy –compose-file docker-compose.yml命令中自动地部署在某台主机上。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">225</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2服务器测试</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">226</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/604/604.htm' target='right' class='orange' >在软件开发中，对于一个服务器而言，良好的测试是一个十分重要的组成部分。</a><a href='../sentence_detail/605/605.htm' target='right' class='orange' >测试可以帮助开发人员筛查代码中出现的错误，是保证软件质量中必不可少的一个环节。</a><span class='green'>通过测试，在服务器开发过程中开发人员可以随时的检验代码的质量，发现潜在的问题，对于代码的修改以及新特性的编写可以保证向前兼容。</span><a href='../sentence_detail/607/607.htm' target='right' class='orange' >对于服务器端而言，通常测试分为代码单元测试与接口测试。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">227</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2.1单元测试</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">228</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中单元测试通常遵循测试驱动开发（ Test Drive Development， TDD）的理念进行，它是一种代码设计准则、测试准则或沟通工具，</span><span class='green'>开发人员通过预先定义好模型与业务代码的接口，然后依据测试接口再开发代码并在开发过程中自动调用预先完成的测试完成开发过程。</span><span class='green'>TDD的好处有以下几：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">229</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/612/612.htm' target='right' class='red' >1、测试代码都是从需求出发的，不是从实现出发的，更关注于对外部的接口;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">230</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/613/613.htm' target='right' class='red' >2、软件的需求都被测试代码描叙得很清楚，可以减少很多不必要的文档;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">231</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/614/614.htm' target='right' class='red' >3、每次实现都是很小的步骤，这样可以集中注意解决一个问题;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">232</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4、可以优化设计。</span><span class='green'>为了实现更简便的单元测试，会让开发者逆向的被迫面向接口编程和使用一些设计模式，自然提高代码设计的灵活性，降低耦合度。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">233</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>基于node.js平台的服务器我们可以采用Mocha 和Chai这两个测试框架实现本文服务端的TDD测试，Mocha是一个单元测试框架，和其他的javascript单元测试框架不同的是，他没有assertion库。</span><span class='green'>但是，Mocha允许使用第三方的断言库，因此我们使用Chai对测试结果进行断言，下面我们给出一个使用Mocha和Chai完成Redis查询缓存读取的测试示范：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">234</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/619/619.htm' target='right' class='red' >describe方法是用来创建一组测试的，并且可以给这一组测试一个描述。</a><span class='green'>一个测试就用一个it方法。</span><span class='green'>it方法的第一个参数是一个描述。</span><a href='../sentence_detail/622/622.htm' target='right' class='red' >第二个参数是一个包含一个或者多个assertion的方法。</a><span class='green'>该范例通过测试getSearchResultCache方法返回的数组结果长度是否与要求一致来测试该函数的正确性，至于结果是否正确则需要通过后面的接口测试来完成。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">235</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/624/624.htm' target='right' class='red' >运行测试只需要在项目的根目录运行命令行：</a><span class='green'>mocha tests －－recursive －－watch。</span><a href='../sentence_detail/626/626.htm' target='right' class='red' >recursive指明会找到根目录下的子目录的测试代码并运行。</a><a href='../sentence_detail/627/627.htm' target='right' class='red' >watch则表示Mocha会监视源代码和测试代码的更改，每次更改之后重新测试。</a><a href='../sentence_detail/628/628.htm' target='right' class='orange' >在该函数未实现前，显然测试会报错误，当正确完成时，该测试示例的运行结果如图5-1所示：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">236</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2.2接口测试</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">237</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于一个 API服务器而言，需要保证业务逻辑的正确性，在客户端请求格式满足预先设计的 HTTP接口规范的情况下，</span><a href='../sentence_detail/631/631.htm' target='right' class='orange' >确保客户端发送的请求服务端可以正确的解析处理并返回正确无误的需求结果。</a><span class='green'>在这种需求下，单纯的单元测试很难完整的验证整个HTTP接口的正确性，特别是无法模拟HTTP的请求，也无法验证响应的状态码与Body是否正确。</span><a href='../sentence_detail/633/633.htm' target='right' class='orange' >因此需要借助第三方的HTTP接口测试软件对服务器的接口进行测试。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">238</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Postman是一个具备许多强大测试特性的 API测试工具，它提供一个易用性较好的 GUI来构造 HTTP Request与读取和测试 HTTP Response，</span><span class='green'>同时 Postman支持将接口测试分享给团队中其他人，或者与团队协同编写接口的测试。</span><span class='green'>Postman也可以将写好的接口测试生成API文档，分享给客户端开发人员作为接口调用与返回数据的定义规范。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">239</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>使用Postman时，首先整个团队需要下载Postman for Linux的桌面版，并注册自己的帐号再加入一个Team中。</span><span class='green'>然后根据分类的需求创建API测试的文件夹，</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">240</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>然后，便可以新建一个窗口来构造HTTP的Request。</span><span class='green'>Postman支持用户构造接口的 URL，请求的 Method， HTTP Header以及 Body，其中 Postman支持以{{}}的方式引用环境变量来构造动态的请求，</span><span class='green'>环境变量可以通过设置全局变量的方式，也可以在每个请求的 Pre- request Script里使用 JS语言设置。</span><span class='green'>对于接口的测试通过对每个接口的 Tests里使用 JS语言编写完成，使用 tests数组来定义断言的结果从而完成测试，</span><span class='green'>当然用户也可以使用该接口测试返回的 Response数据来设置环境变量，以用作后续接口的测试，</span><span class='green'>实现前后接口的上下文通信，例如，通过以下 Request请求 Token;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">241</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>将返回的Token结果存为环境变量，在后续的API请求中通过在请求中使用--header ’authorization:</span><span class='green'>{{token}}’ 设置HTTP Header从而解决Token需要动态授权不方便测试的问题。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">242</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后构造编写完所有接口的请求与测试后，设置测试次数 ，运行Postman中的接口集合测试，测试结果如下图：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">243</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>则表示服务端通过了所有的已设计接口测试，能够满足客户端正常的业务请求。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">244</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.3性能分析与监控</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">245</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.3.1访问负载压力分析</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">246</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>服务器的根本职责是接受并解析客户端的访问请求，对数据处理后返回请求所需的数据或状态，在HTTP通信的每一个阶段都需要一定的计算与内存资源来支持。</span><span class='green'>而客户端的数目会随着企业业务规模的扩展而迅速扩增，因此在同一时间内可能会有大量的客户端请求同时发向服务端，</span><a href='../sentence_detail/653/653.htm' target='right' class='orange' >造成服务器计算资源或内存资源耗尽，使得服务器的 CPU无法及时响应每个客户端的</a><a href='../sentence_detail/654/654.htm' target='right' class='orange' >请求，甚至会导致服务器主机整个操作系统因为计算资源枯竭而崩溃造成宕机。</a><a href='../sentence_detail/655/655.htm' target='right' class='orange' >正因如此，对于一个服务器而言，通常用户人员会对服务器的访问负载压力进行测试与分析，</a><span class='green'>从而预先检验服务器当前的计算性能是否能够满足企业实际生产中的用户访问负载需求。</span><a href='../sentence_detail/657/657.htm' target='right' class='orange' >对于服务器压力测试主要包括以下指标:</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">247</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1、吞吐率（Requests per second）。</span><span class='green'>概念：</span><a href='../sentence_detail/660/660.htm' target='right' class='red' >服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。</a><a href='../sentence_detail/661/661.htm' target='right' class='red' >某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">248</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>计算公式：</span><a href='../sentence_detail/663/663.htm' target='right' class='red' >总请求数 / 处理完成这些请求数所花费的时间;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">249</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2、并发连接数（The number of concurrent connections）。</span><span class='green'>概念：</span><a href='../sentence_detail/666/666.htm' target='right' class='red' >某个时刻服务器所接受的请求数目，简单的讲，就是一个会话;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">250</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3、并发用户数（The number of concurrent users，Concurrency Level）。</span><span class='green'>概念：</span><a href='../sentence_detail/669/669.htm' target='right' class='red' >要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">251</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4、用户平均请求等待时间（Time per request）。</span><span class='green'>计算公式：</span><a href='../sentence_detail/672/672.htm' target='right' class='red' >处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数）;</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">252</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5、服务器平均请求等待时间（Time per request:</span><span class='green'>across all concurrent requests）。</span><span class='green'>计算公式：</span><a href='../sentence_detail/676/676.htm' target='right' class='orange' >处理完成所有请求数所花费的时间 / 总请求数，可以看到，它是吞吐率的倒数。</a><a href='../sentence_detail/677/677.htm' target='right' class='red' >同时，它也=用户平均请求等待时间/并发用户数。</a>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_6.htm">上一页</a>
<a class="pagelink" href="paper_8.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：7/8页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
