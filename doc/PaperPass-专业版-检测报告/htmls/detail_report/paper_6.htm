<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_5.htm">上一页</a>
<a class="pagelink" href="paper_7.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：6/8页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">178</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>互联网起初将“网络资源”定义为经过URLS区分的文档或文件，但是现今无论任何事物或实体，在网上它们都有一个更通用和更抽象的定义，可以是唯一识别，命名或地址等任何方式。</span><span class='green'>在基于Rest的Web服务中，对资源URI的请求将获得可能是XML、HTML、JSON或其他已定义格式的响应。</span><span class='green'>响应可能会确认已对存储资源进行了一些更改，并可能提供相关资源或资源集合的超文本链接。</span><span class='green'>最常见的是使用HTTP协议，可用的操作包括使用HTTP中GET、POST、PUT、DELETE等预定义的操作方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">179</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/492/492.htm' target='right' class='orange' > REST描述了一个架构样式的互联系统（如 Web应用程序），通过使用无状态的协议和标准行为，</a><span class='green'>一个 REST系统将高性能与高可靠性，同时获得动态弹性增长的能力。</span><span class='green'>通过重用组件，可以不影响系统运行下进行资源的管理和更新，尽量它们作为一个整体正在运行。</span><a href='../sentence_detail/495/495.htm' target='right' class='red' >REST 约束条件作为一个整体应用时，将生成一个简单、可扩展、有效、安全、可靠的架构。</a><a href='../sentence_detail/496/496.htm' target='right' class='red' >由于它简便、轻量级以及通过 HTTP 直接传输数据的特性，RESTful Web 服务成为基于 SOAP 服务的一个最有前途的替代方案。</a><a href='../sentence_detail/497/497.htm' target='right' class='red' >用于 web 服务和动态 Web 应用程序的多层架构可以实现可重用性、简单性、可扩展性和组件可响应性的清晰分离。</a><a href='../sentence_detail/498/498.htm' target='right' class='red' >开发人员可以轻松使用 Ajax 和 RESTful Web 服务一起创建丰富的界面。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">180</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.3.1基于Express框架开发</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">181</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/500/500.htm' target='right' class='red' >Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。</a><a href='../sentence_detail/501/501.htm' target='right' class='red' >丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。</a><a href='../sentence_detail/502/502.htm' target='right' class='red' >Express 不对 Node.js 已有的特性进行二次抽象，本文只是在它之上扩展了 Web 应用所需的基本功能。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">182</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Express 的优点是线性逻辑：</span><span class='green'>路由和中间件完美融合，通过中间件形式把业务逻辑细分，简化，一个请求进来经过一系列中间件处理后再响应给用户，再复杂的业务也是线性了，清晰明了。</span><span class='green'>中间件模式就是把嵌套的异步逻辑拉平了，但它也只能是从较宏观的层面解耦顺序执行的异步业务，</span><span class='green'>它无法实现精细的异步组合控制，比如并发的异步逻辑，比如有相对复杂条件控制的异步逻辑。</span><span class='green'>开发通常会要借助 async、bluebird 等异步库。</span><span class='green'>但即便有了这类异步库，当涉及到共享状态数据时，仍然不得不写出嵌套异步逻辑。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">183</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本文先通过代码 express()声明一个新的 Express实例的 server，通过以下代码首先为 server添加必要的中间件，</span><span class='green'>包括 body与 cookie的解析， session的解析存储， passport中间件的使用，关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">184</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/511/511.htm' target='right' class='orange' >其中HTTPS监听是建立在 TLS/SSL 之上的 HTTP 协议，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</a><a href='../sentence_detail/512/512.htm' target='right' class='red' > 它是一个URI scheme（抽象标识符体系），句法类同http:</a><span class='green'>体系。</span><span class='green'>用于安全的HTTP数据传输。</span><a href='../sentence_detail/515/515.htm' target='right' class='red' >SSL（Secure Sockets Layer，安全套接层），及其继任者 TLS（Transport Layer Security，传输层安全）是为网络通信提供安全及数据完整性的一种安全协议。</a><a href='../sentence_detail/516/516.htm' target='right' class='orange' >TLS与SSL在传输层对网络连接进行加密，在创建HTTPS监听之前，需要先生成服务器自己的HTTPS证书，步骤如下：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">185</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1、为CA生成私钥：</span><span class='green'>openssl genrsa -out ca-key.pem -des 1024</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">186</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2、通过CA私钥生成CSR：</span><span class='green'>openssl req -new -key ca-key.pem -out ca-csr.pem</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">187</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3、通过CSR文件和私钥生成CA证书：</span><span class='green'>openssl x509 -req -in ca-csr.pem -signkey ca-key.pem -out ca-cert.pem</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">188</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4、为服务器生成私钥：</span><span class='green'>openssl genrsa -out server-key.pem 1024</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">189</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/525/525.htm' target='right' class='orange' >5、利用服务器私钥文件服务器生成CSR：</a><span class='green'>openssl req -new -key server-key.pem -config openssl.cnf -out server-csr.pem</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">190</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/527/527.htm' target='right' class='orange' >6、通过服务器私钥文件和CSR文件生成服务器证书：</a><span class='green'>openssl x509 -req -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -in server-csr.pem -out server-cert.pem -extensions v3_req -extfile openssl.cnf</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">191</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后在node-js中为server监听80与443端口分别作为http与http的请求端口，代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">192</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.3.2使用node-restful开发标准Restful接口</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">193</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>node-restful是Express框架下的一个网络中间件，通过配合Mongoose Schema模型层资源，自动地构建标准Restful API接口与路由，其中node-restful支持的路由类型有：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">194</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>node-restful提供一些方法在用户注册Mongoose Schema资源后，供用户生成接口，其中通过命令methods([...]) 可以声明一个允许资源操作的方法列表。</span><span class='green'>当用户不希望该资源对外暴露某些接口时，只需要将该方法从参数中删除即可，例如通过Resource.methods([’get’， ’post’， ’put’])可以禁用Delete操作。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">195</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>同时 node- restful当然也允许注册其他的路由请求，例如通过代码 Resource. route(’ recommend’，</span><span class='green'>function( req， res， next)便可以注册一个设置在/ resources/ recommend路径的路由操作，</span><span class='green'>这个方法将会被应用到所有的方法列表中，当然也可以通过例如 Resource. route(’ recommend. get’，</span><span class='green'>function( req， res， next)的代码覆写某个已注册的方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">196</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>通过 node- restful，我们也可以通过 node- restful提供的 before( method， function)为路由方法设置 Filter拦截器，</span><span class='green'>例如对于用户登录的路由方法而言，我们可以通过以下代码，使用 bcrypt模块将用户密码明文加盐后加密，</span><span class='green'>再存储进 Mongo数据库中：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">197</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于所有业务数据的请求必须经过OAuth2.0协议的验证，因此再所有的接口前，我们需要加上对Bearer Token的验证的before方法，关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">198</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于水质处理流程监控数据而言，我们需要先从 Redis缓存中查询需要的缓存数据，对于命中的查询结果直接返回 Response，</span><span class='green'>因此需要在所有模型层的 get请求前添加 getCache方法，关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">199</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>随后 node- restful将会根据 Mongoose Schema自动地向 Mongo数据库查询、插入、更新或者删除数据，并返回结果到 Response中，</span><span class='green'>对于服务端而言，我们在数据库操作完成后，对于 get请求，将过于大量的数据压缩与筛选，对于 post请求，</span><span class='green'>需要将新插入的数据更新到 Redis缓存中， node- restful提供了 after( method， function)方法，将返回的查询数据存储在 res. locals中，</span><span class='green'>其中 res. locals. statusCode是请求的返回状态吗， res. locals. bundle则是查询的结果，基于以下代码，</span><span class='green'>我们为 post请求处理后更新 redis缓存结果，关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">200</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>node-restful同时也提供丰富与标准的符合Restful的查询过滤条件，基于此，我们可以开发出可用性极高的Restful标准API，其中基于node-restful实现的过滤条件包括表4-1：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">201</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>过滤条件查询请求示例描述</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">202</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后我们先通过代码const router = new express.Router()声明一个新的路由，再通过代码Resource.register(router， ’/resources’)将Resource模型注册到/resources路径上。</span><span class='green'>在 node的主函数 server. js中，为 server添加先前声明的 API与 AUTH的路由，代码分别为 server. use(’/’，</span><span class='green'>authRouter)与 server. use(’/ api’， apiRouter)，通过路由，我们可以将 authRouter里注册的路径仍然路由在根路径下，</span><span class='green'>而 apiRouter里注册的路径，重新路由到/ api后，例如 GET/ api/ Resource/:</span><span class='green'>id，至此我们便完成了处理服务器的开发。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">203</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第五章 服务器配置与测试及性能分析</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">204</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1服务器配置与测试</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">205</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/558/558.htm' target='right' class='orange' >5.1.1单台主机配置多进程处理服务器实例</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">206</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于处理服务器是基于 node. js平台实现的，而 node. js使用的 Chrome V8引擎是一个单线程的进程，</span><span class='green'>因此对于 node. js应用而言单个进程无法很好的利用服务器多核心的计算优势，从而造成一定的计算资源浪费。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">207</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>正是基于这样的背景需求，PM2工具应运而生。</span><span class='green'>PM2是一个nodejs应用的进程管理工具，通过对CPU核心的绑定实现单台物理或虚拟主机上的资源均衡负载，以多进程的方式最大效率利用多核CPU的特性。</span><span class='green'>同时，它通过自动重启的方法保持node.js进程即使发生错误仍然可以重启来保证服务器的可用性。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">208</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>配置通过 PM2启动 nodej. s应用的方法是编写 PM2的 process. yml配置文件，来配置 node. js应用启动的参数、环境行为、变量以及 log路径等，</span><span class='green'>对于本文的处理服务器，我们编写以下 process. yml文件来启动：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">209</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中exec_mode:</span><span class='green'>’ cluster’指的是开启 PM2的 cluster启动模式，它允许根据可用的 CPU数量来弹性地启动相应数量的 node. js应用进程实例，</span><span class='green'>而不需要做其他的一些额外代码修改，然后自动地将路由到该台物理主机的请求均衡负载到相应的进程实例中。</span><span class='green'>而watch :</span><span class='green'>[’server/’]将会监视server文件夹下的所有代码文件，当有文件修改时，无需额外的操作与等待便可立即热部署最新的代码。</span><a href='../sentence_detail/571/571.htm' target='right' class='orange' >因此对于多核CPU的服务器而言，它可以极大的提升应用的性能与可用性。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">210</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1.2配置处理服务器集群</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">211</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于多台物理或虚拟主机构成的集群，我们需要通过 Docker及其相关的 Docker组件编写一系列的脚本配置文件，</span><a href='../sentence_detail/574/574.htm' target='right' class='orange' >以支持在集群中的每台物理主机上自动地启动处理服务器实例，从而最大的利用集群的计算资源。</a><span class='green'>并且在集群的性能出现瓶颈，无法满足用户的服务需求快速增长时，可以弹性的将新的物理主机加入集群中并自动启动新的处理服务器实例。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">212</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>首先，我们在Dokcer Compose的配置文件中，编写处理服务器的编排：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">213</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中，通过command:</span><span class='green'>pm2- docker-- watch./ config/ process. yml命令用 PM2启动多进程处理服务器实例，利用当前目录的 Docker File来 Build Docker镜像，</span><span class='green'>并绑定到 Docker Hub的 gjscut/ water_ watcher_ api_ server远端镜像上。</span><span class='green'>然后添加Redis与MongoDB数据库容器的链接，以加入自身容器的DNS列表来访问。</span><a href='../sentence_detail/581/581.htm' target='right' class='orange' >通过Volumes将本地文件的代码挂载在容器上，实现容器中代码的热更新。</a><span class='green'>最后将主机的80端口与443端口与容器的相应端口映射，以实现Http与Https的访问。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_5.htm">上一页</a>
<a class="pagelink" href="paper_7.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：6/8页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
