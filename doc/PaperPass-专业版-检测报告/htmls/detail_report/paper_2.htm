<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="paper_3.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：2/8页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">38</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图1 VM与Container技术架构对比图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">39</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.1.1 Docker容器工具</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">40</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/97/97.htm' target='right' class='red' > Docker是 Dot Cloud公司基于 go语言开发的一个基于 LXC的高级容器引擎，源代码托管在 Github上，并遵从 Apache2.0协议开源，</a><span class='green'>也是目前容器技术中最有主流的代表，用户可以从 Docker Hub上 Pull经过认证的或其他个人 Push的公有容器镜像直接使用，</span><span class='green'>也可以自己通过编写 Docker file文件构建其自身的容器镜像。</span><span class='green'>使用Docker file构建容器可以通过FROM命令在一个公有容器基础上构建自己的容器。</span><span class='green'>每个容器具备自己的计算机文件、进程、端口资源与接口，通过VOLUMES命令挂载本地文件与配置。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">41</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/102/102.htm' target='right' class='orange' >Docker解决了运行环境依赖问题，不再有更换运行环境后应用无法正常启动的问题。</a><a href='../sentence_detail/103/103.htm' target='right' class='red' >如果说LXC着眼点在于提供轻量级的虚拟技术，扎根在虚拟机，那Docker则定位于应用。</a><a href='../sentence_detail/104/104.htm' target='right' class='red' >Docker所为人称道的portability、application-centric、versioning等等超越传统虚拟技术的优点都跟它的封装性密不可分。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">42</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.1.2 Docker Machine主机管理工具</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">43</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Docker Machine是一种可以让用户在虚拟主机上安装Docker实例，并且通过Docker Machine命令管理主机的工具。</span><span class='green'>用户可以通过Docker Machine可以在不同平台上（不管是本地Mac或者Windows或者Azure、 Rackspace、OpenStack、Google等云平台）创建Docker主机。</span><span class='green'>利用Docker Machine命令，用户可以方便的启动、监控、重启Docker主机，配置Docker客户端与实例。</span><span class='green'>Docker Machine结合VMWARE可以作为一个方便的虚拟机管理工具，使得用户可以方便的创建以及管理虚拟机，并可通过创建一个集群桥接网络，实现不同主机间的通信。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">44</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.1.3 Docker Compose容器编排工具</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">45</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Docker Compose是一个编排并启动多个容器应用的工具。</span><span class='green'>通过Compose，用户可以编写Compose file来配置自己的应用服务，然后利用一些简单的命令，便可以创建、开始、停止、重启所有配置中的服务。</span><span class='green'>Compose如一个CI工作流一般，对于开发、测试及运维来说都是十分方便的。</span><span class='green'>用户可以在 Compose file中定义容器的镜像或者 Build环境、内外端口映像、启动方式、启动命令，并且可以通过 Links命令将不同容器的地址写入相应容器的 DNS中，</span><span class='green'>同时通过配置 Overlay网络，可以让容器在一个共享的网络中通信。</span><span class='green'>利用Scale命令，Docker Compose可以轻松的在任意时刻对某个容器进行扩容。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">46</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2容器管理工具</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">47</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/118/118.htm' target='right' class='red' >很明显，容器在创建和交付应用程序的过程中有着新发展。</a><a href='../sentence_detail/119/119.htm' target='right' class='red' >然而，大范围控制容器部署也会有一些并发症。</a><span class='green'>容器肯定是跟资源相匹配的。</span><span class='green'>故障肯定是越快解决越好。</span><a href='../sentence_detail/122/122.htm' target='right' class='red' >这些挑战会导致集群管理和编排的并发需求。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">48</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/123/123.htm' target='right' class='red' >集群管理工具是一个通过图形界面或者通过命令行来帮助你管理一组集群的软件程序。</a><a href='../sentence_detail/124/124.htm' target='right' class='red' >有了这个工具，你就可以监控集群里的节点，配置 services ，管理整个集群服务器。</a><a href='../sentence_detail/125/125.htm' target='right' class='red' >集群管理可以从像发送工作到集群的低投入活动，到像均衡负载和可得性的高介入工作。</a><span class='green'>主流的容器管理工具有 Google公司开发的工具 Kubernetes，与 Docker原生的 Docker Swarm，由于 Kubernetes相对学习成本较高，</span><span class='green'>命令与 Docker差别很大，更适用于管理容器数量巨大的引用，因此直接采用原生的 Docker Swarm来管理容器对于服务数量复杂度不高的应用是最佳的选择。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">49</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Docker Swarm是一个原生的Docker集群工具，让一系列的 Docker主机集群转化为一个单一的虚拟的Docker主机。</span><a href='../sentence_detail/129/129.htm' target='right' class='red' >在一个分布式应用程序环境中，计算元素必须也是可以被分布的。</a><span class='green'>Swarm 允许你在本地聚集 Docker 引擎。</span><a href='../sentence_detail/131/131.htm' target='right' class='red' >有了单个引擎，应用程序可以被扩展得更快，更有效率。</a><a href='../sentence_detail/132/132.htm' target='right' class='red' >Swarm 能够扩容到 50000 个容器， 1000 个节点，同时当容器添加到集群的时候一点都不影响性能。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">50</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>再加上， Swarm 的角色相当于 Docker API。</span><a href='../sentence_detail/134/134.htm' target='right' class='red' >任意可以操作Docker Daemon 的工具都可以运用Docker Swarm的力量在很多主机上进行扩容，包括了像 Flynn，Compose，Jenkins和Drone之类不同的主机。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">51</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/135/135.htm' target='right' class='orange' >Swarm 遵循“swap， plug， play”的原则，意味着也可以在后端运行 Mesos 或者 Kubernetes 的时候，被用来作为前端 Docker 客户端。</a><span class='green'>Swarm 在它的核心内部是一个简单的系统：</span><a href='../sentence_detail/137/137.htm' target='right' class='red' >每个主机运行一个 Swarm 代理与管理员。</a><span class='green'>管理员处理容器的操作和调度。</span><a href='../sentence_detail/139/139.htm' target='right' class='red' >你可以在高可用状态下运行，它使用的是 Consul， ZooKeeper或者etcd来发送容错 events到后端系统。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">52</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/140/140.htm' target='right' class='red' >Docker Swarm的一个优点就是，它是一个本地解决办法——你可以用Docker命令来实施Docker网络，插件和数据卷。</a><span class='green'>Swarm 管理员为 leader 选举创建一些 master 和特定的规定。</span><span class='green'>这些条例实施在初级 master 故障的 event 里。</span><a href='../sentence_detail/143/143.htm' target='right' class='red' > Swarm调度器以各种各样的过滤包为特色，也包括紧密性和节点标签。</a><a href='../sentence_detail/144/144.htm' target='right' class='red' >过滤包能够附加容器到底层节点，资源得到更好的利用，性能得到提升。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">53</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在网络上创建Swarm节点的第一步是Pull Docker Swarm镜像。</span><span class='green'>然后，利用Docker配置Swarm Manager与其余的节点来启动Docker Swarm。</span><span class='green'>这需要用户做到：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">54</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1、对于每个节点启动一个TCP端口用于与Swarm Manager通信；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">55</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2、安装Docker在每个节点上</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">56</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3、创建与管理TLS信任证书来保证集群的安全</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">57</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最佳的方式便是利用Docker Machine来完成这些，Docker Machine已经安装了Docker实例，并且可以自动地创建信任证书与其余的Docker Machine实例组成安全的集群网络。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">58</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.3 均衡负载器</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">59</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/153/153.htm' target='right' class='orange' >均衡负载器，英文名为 Load Balance，是一个 Apache HTTP均衡负载器，通过反向代理的方式，</a><a href='../sentence_detail/154/154.htm' target='right' class='orange' >它将作为一个单一的 web请求入口点，接受所有的客户端服务请求，然后根据一定的均衡算法，</a><a href='../sentence_detail/155/155.htm' target='right' class='orange' >将请求路由到处理服务器集群上相同的 web服务器处理实例中。</a><span class='green'>需要说明的是：</span><a href='../sentence_detail/157/157.htm' target='right' class='red' >均衡负载器并不是必须的基础网络设备，而是一种性能优化设备。</a><a href='../sentence_detail/158/158.htm' target='right' class='red' >对于网络应用而言，并不是一开始就需要负载均衡，当网络应用的访问量不断增长，</a><a href='../sentence_detail/159/159.htm' target='right' class='red' >单个处理单元无法满足负载需求时，网络应用流量将要出现瓶颈时，负载均衡才会起到作用。</a><span class='green'>常用的均衡负载器有Nginx，通过Nginx可以十分容器地实现多个请求路径的反向代理与均衡负载的功能，通过location的匹配实现路径的匹配，同时也可以用于静态资源的缓存。</span><span class='green'>Nginx还可以实现HTTP Response的缓存与压缩等诸多功能。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">60</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>该容器由config/consul文件夹下的Docker file基于官方认证的nginx容器所构建，代码为：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">61</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/163/163.htm' target='right' class='orange' >通过挂载本地的nginx.conf实现对nginx的配置，完成反向代理与均衡负载的功能，其中均衡负载与反向代理的关键代码为：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">62</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4 服务发现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">63</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/165/165.htm' target='right' class='orange' >对于微服务架构的服务器而言，服务发现功能是一个极其重要的组成部分。</a><span class='green'>由于服务不可能是预先定义好不变的，随着服务运行中的弹性扩展，重启，转移，服务的地址与端口都可能发生改变，</span><span class='green'>原有依赖于这些服务的服务将会因此发生错误，而运行时创建的服务，也需要通过服务发现，将其地址加到均衡负载器的 DNS列表，</span><span class='green'>然后加入到均衡负载器的负载流中。</span><span class='green'>对于需要依赖这些动态创建服务的服务，也需要服务发现功能，来动态的获取可用服务的DNS列表。</span><span class='green'>常用的服务发现有Consul， ZooKeeper或者etcd以及Docker Swarm自带的服务发现功能。</span><span class='green'>本文采用Consul作为服务发现工具。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">64</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Consul具备多个组件，总体而言，它是一个用于服务发现与配置的工具，它提供以下关键的特性：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">65</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1．服务发现：</span><span class='green'>Consul客户端可以将一个服务注册，其他Consul客户端来发现提供者的服务，利用DNS或者HTTP，应用可以轻松地利用这些服务。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">66</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2．健康检查：</span><span class='green'>Consul客户端提供一定数量的健康检查，通过测试给定服务是否返回200 OK或者本地节点内存是否低于90%。</span><span class='green'>这些信息可以提供给集群监控健康，并被服务发现组件避免路由到不健康的主机</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">67</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3．KV存储：</span><a href='../sentence_detail/179/179.htm' target='right' class='orange' >应用可以利用Consul的key/value数据库存储一定目标数据，包括动态配置，特性标志等。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">68</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4．多数据中心：</span><span class='green'>Consul支持多个数据中心，意味着用户不需要担心构建额外的抽象层来增加多个局部实例。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">69</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Consul是一个分布式的、高可用的系统，每一个节点提供了运行Consul Agent的服务，Agent就像节点自己一样负责节点服务的健康检查。</span><span class='green'>所有节点通知一个或多个的Consul服务端，Consul服务端用于存储与备份，它们会选取一个leader，通过主从备份防止数据丢失。</span><span class='green'>当用户需要用到服务发现时，可以通过任意Agent或Server查询，Agent会自动地将查询转发给Server。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">70</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>通过绑定 Docker端口的 Registrator可以自动地将 Docker运行中的所有服务及相应的端口注册到 Consul Server中，</span><a href='../sentence_detail/186/186.htm' target='right' class='orange' >随后通过在均衡负载器中启动一个 Consul Client，在有新的处理服务器加入到集群中时，</a><span class='green'>便可动态地将新的服务地址与端口注册到均衡负载器，从而实现弹性扩容。</span><span class='green'>当有服务关闭时，健康检查功能也将该服务从均衡负载器中剔除。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="paper_3.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：2/8页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
