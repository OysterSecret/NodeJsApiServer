<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：3/8页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">71</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>编写在Nginx中运行的Consul Client的服务发现template服务，使得处理服务器集群增加或删除时，订阅通知更新Nginx的配置文件，重新配置均衡负载流：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">72</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在Nginx的Docker file中下载Consul Client Template并启动template服务以接收Consul Server对于新启动容器的通知：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">73</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第三章 数据库池设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">74</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.1数据库选择</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">75</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在过去的企业服务端架构中，传统的关系型数据库（RDBMS）占据了市场上的绝对主流地位，例如MySQL，Oracle，SQL Server等。</span><span class='green'>由于关系型数据库基于集合代数的原理设计，用户通过SQL语言可以很方便的实现联表查询，能够满足十分复杂的业务查询功能，提供了数据的存储、访问以及保护能力。</span><a href='../sentence_detail/195/195.htm' target='right' class='orange' >通过对ACID原则的全面支持，即交易的原子性、一致性、隔离性与持久性，使得RDBMS具备很强的实用性与可靠性。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">76</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>然而随着互联网时代的到来，用户数目与数据容量的爆炸式增长使得传统的关系型数据库显的愈发力不从心。</span><span class='green'>基于 Web的大量数据处理与分析需要要求极高的数据库查询速率，而在企业的实际应用中发现，</span><a href='../sentence_detail/198/198.htm' target='right' class='orange' >并不是所有数据都必须实现强一致性，即时偶尔有些非重要数据发生错误也不影响系统的正常使用，</a><a href='../sentence_detail/199/199.htm' target='right' class='red' >非强一致性模型以及更小的处理消耗更适合快速变化的动态环境。</a><span class='green'>由下图3-1可以了解到，近年来非结构化的数据增长原快于结构化的数据增长，对于传统的关系型数据库而言处理这些非结构型数据是不合适的。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">77</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/201/201.htm' target='right' class='orange' >在这种背景需求下，非结构型的数据库（ NoSQL）应运而生， NoSQL数据库相比于关系型数据库提供了更灵活的数据库模式（ Schema），</a><a href='../sentence_detail/202/202.htm' target='right' class='red' >其中每一个数据元素不需要存在于每一个数据实体当中。</a><a href='../sentence_detail/203/203.htm' target='right' class='red' >定义更松散的数据结构会随着时间的推移而进化，因此在一些特定场景下NoSQL数据库会是更加实际的解决方案。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">78</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/204/204.htm' target='right' class='red' >NoSQL与关系型数据库的另外一个不同就是数据一致性的提供方式。</a><a href='../sentence_detail/205/205.htm' target='right' class='red' >关系型数据库可以确保存储的数据永远保持一致性，而大多数NoSQL数据库产品提供了更松散的一致性方式。</a><a href='../sentence_detail/206/206.htm' target='right' class='red' >事实上，关系型数据库产品已经可以提供不同级别的数据库锁、一致性与隔离性，而一些NoSQL则提供了多种一致性模型，可以支持完整的ACID。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">79</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/207/207.htm' target='right' class='red' >NoSQL解决了一些关系型数据库不能解决的问题，针对海量数据的处理更得心应手。</a><a href='../sentence_detail/208/208.htm' target='right' class='red' >实际生产中数据被认为是稀疏的，不是所有元素都被填充，在实际值中还有很多的“空白空间”。</a><span class='green'>NoSQL通过基于稀疏矩阵的处理方式使得数据库处理这些数据的能力大幅增强。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">80</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/210/210.htm' target='right' class='red' >尽管NoSQL在特定的数据类型上有着一定优势，但与关系型数据库相比它的劣势也是非常明显的。</a><a href='../sentence_detail/211/211.htm' target='right' class='red' >比如，交易完整性、灵活索引以及查询易用性的缺失等。</a><a href='../sentence_detail/212/212.htm' target='right' class='red' >此外，NoSQL还包含了四个不同的类别，用来支持不同的应用：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">81</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>• 键值型数据库（Key-value）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">82</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>• 文档型数据库（Document）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">83</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>• 列式数据库（Columnstore）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">84</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>• 图型数据库（Graph）</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">85</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>同时对于一些实时性极强，查询频率高但是数据量小的数据模型，基于文件系统的关系型数据库也不再适合，内存数据库解决了这一问题。</span><a href='../sentence_detail/218/218.htm' target='right' class='red' >内存数据库有时也称为主内存数据库。</a><a href='../sentence_detail/219/219.htm' target='right' class='red' >一个内存数据库主要通过内存来存储数据，这与基于磁盘的存储有所不同。</a><a href='../sentence_detail/220/220.htm' target='right' class='red' >内存数据库的主要应用场景就是改善性能。</a><a href='../sentence_detail/221/221.htm' target='right' class='red' >数据存储在内存介质当中，I/O延迟将得到大大削减。</a><a href='../sentence_detail/222/222.htm' target='right' class='red' >因为机械硬盘的转动、寻道时间以及传输到缓存器的动作在内存中都被省去了。</a><a href='../sentence_detail/223/223.htm' target='right' class='red' >内存数据库主要针对内存数据访问进行了优化，而传统数据库则是针对磁盘进行的数据访问优化。</a><a href='../sentence_detail/224/224.htm' target='right' class='red' >内存数据库产品还可以减少开销，因为其内部算法通常更加简单，需要更少的CPU指令。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">86</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.2MongoDB数据库</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">87</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/226/226.htm' target='right' class='red' >MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</a><a href='../sentence_detail/227/227.htm' target='right' class='red' >在高负载的情况下，可以添加更多的节点，可以保证服务器性能。</a><a href='../sentence_detail/228/228.htm' target='right' class='red' >MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</a><span class='green'>它可以构建一个NoSQL集群，应对当前大数据量，大规模运算以及高并发的需求。</span><a href='../sentence_detail/230/230.htm' target='right' class='red' >MongoDB 将数据存储为一个文档，数据结构由键值(key=]value)对组成。</a><span class='green'>MongoDB 文档类似于 JSON 对象。</span><a href='../sentence_detail/232/232.htm' target='right' class='red' >字段值可以包含其他文档，数组及文档数组。</a><a href='../sentence_detail/233/233.htm' target='right' class='red' >Mongodb也支持Map/reduce操作，主要是用来对数据进行批量处理和聚合操作。</a><a href='../sentence_detail/234/234.htm' target='right' class='red' >Map函数调用emit(key，value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</a><span class='green'>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">88</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.2.1副本集</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">89</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/237/237.htm' target='right' class='red' >MongoDB副本集是将数据同步在多个服务器的过程。</a><a href='../sentence_detail/238/238.htm' target='right' class='red' >复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</a><a href='../sentence_detail/239/239.htm' target='right' class='red' >复制还允许您从硬件故障和服务中断中恢复数据。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">90</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>mongodb的副本集至少需要两个节点。</span><a href='../sentence_detail/241/241.htm' target='right' class='red' >其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。</a><span class='green'>mongodb各个节点常见的搭配方式为：</span><span class='green'>一主一从、一主多从。</span><a href='../sentence_detail/244/244.htm' target='right' class='red' >主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</a><span class='green'>MongoDB复制结构图如下图3-2所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">91</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中每一个副本集是一个由 Primary主数据库以及1个或多个 Secondary从数据库组成的一个集合，集合中每个数据库保存相同的数据，</span><a href='../sentence_detail/247/247.htm' target='right' class='red' >并由主数据库负责实际的业务读写，客户端主节点读取数据，在客户端写入数据到主节点时，主节点与从节点进行数据交互保障数据的一致性，</a><span class='green'>从数据库作为容灾备份。</span><a href='../sentence_detail/249/249.htm' target='right' class='red' >Replica Sets的结构类似一个集群，完全可以把它当成一个集群，因为它确实与集群实现的作用是一样的：</a><a href='../sentence_detail/250/250.htm' target='right' class='red' >如果其中一个节点出现故障，其他节点马上会将业务接管过来而无须停机操作。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">92</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>一个由一台主节点和两个副节点的副本集Compose编排如下，通过mongod --replSet rs1 --shardsvr --port 27017命令将三个节点设为同一副本集：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">93</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在所有节点启动后，连接主数据库节点配置副本集，配置命令如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">94</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>至此，完成了一个 MongoDB副本集集群的配置，用户可以通过任意一个节点，对数据库进行访问，</span><span class='green'>不管任意节点宕机时，副本集将会路由到剩余的可用节点访问数据。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">95</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.2.2通过分片实现均衡负载</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">96</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/256/256.htm' target='right' class='red' >在Mongodb里面存在另一种集群，就是分片技术，可以满足MongoDB数据量大量增长的需求。</a><a href='../sentence_detail/257/257.htm' target='right' class='red' >当 MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量，</a><a href='../sentence_detail/258/258.htm' target='right' class='red' >并且由于复制所有的写入操作到主节点，延迟的敏感数据会在主节点查询，单个副本集限制了12个节点，</a><span class='green'>当请求量巨大时会出现内存不足，本地磁盘不足，垂直扩展价格高昂等原因，单一的副本集已无法支持业务的增长。</span><a href='../sentence_detail/260/260.htm' target='right' class='red' >这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">97</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/261/261.htm' target='right' class='red' >分片是某一集合中负责某一子集的一台或多台服务器。</a><a href='../sentence_detail/262/262.htm' target='right' class='orange' >MongoDB会自动地将数据均匀分布在分片上，同时最小化需要被移动的数据量。</a><span class='green'>MongoDB在集群入口会启动Mongos服务来隐藏分片之间复杂性向用户提供一个服务接口，并作为一个路由节点接受用户的所有读写。</span><a href='../sentence_detail/264/264.htm' target='right' class='orange' >同时MongoDB还会存在一个配置服务器保存集群的配置信息。</a><span class='green'>整个MongoDB集群组成部件结构如下图：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">98</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/266/266.htm' target='right' class='orange' >其中多个路由节点可以起到均衡负载与容灾的作用，</a><span class='green'>防止出现路由节点宕机的情况，配置服务器负责将单个 MongoDB中的数据分片到多个副本集的实例上，</span><span class='green'>配置服务器的个数与一个副本集中的节点个数一致，启动配置服务器的命令与启动普通副本集的 MongoDB实例类似，</span><span class='green'>启动后通过以下命令配置：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">99</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后在路由实例中，通过mongos将配置服务器端口加入路由列表启动，命令如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">100</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后连接路由实例将副本集端口加入即可，命令如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">101</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/272/272.htm' target='right' class='orange' >由此，便成功创建了由6个Mongo副本集存储实例，3个配置实例，1个路由实例组成的MongoDB数据库集群。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">102</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.2.3创建数据集合</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">103</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/274/274.htm' target='right' class='red' >MongoDB 是一种面向文档(document-oriented)的数据库，其内存储的是一种 JSON-like 结构化数据。</a><span class='green'>尽管拥有和关系型数据库 Database/Table 类似的的 DB/Collection 概念，但同一 Collection 内的 Document 可以拥有不同的属性。</span><a href='../sentence_detail/276/276.htm' target='right' class='red' >集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</a><span class='green'>MongoDB的元数据支持String，Integer，Boolean，Double，Min/Max keys，Arrays，Timestamp，Date，Object ID，Binary Data ，Code，Regular expression等数据类型。</span><span class='green'>同时在MongoDB里对于模型之间关系的表示，即可以用Link，又可以用Embedded，Link主要用于表示多对多的关系，Embedded主要表示包含的关系，基于此，我们通过JSON文档的方式，以fildName:</span><span class='green'>{options}的格式，为所有数据模型创建MongoDB集合。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">104</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>对于水厂监控的服务器而言，由于需要查询实时历史数据与最近的历史统计数据，因此查询数据需要根据数据插入时间进行排序，</span><span class='green'>MongoDB提供了自动创建时间戳的方式，为每个文档建立创建与更新的时间戳，以用于排序，</span><span class='green'>方法只要在创建 Schema时 option使用{ versionKey:</span><span class='green'>false， timestamps:</span><span class='green'>{ createdAt:</span><span class='green'>’createTime’， updatedAt:</span><span class='green'>’updateTime’ } }</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：3/8页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
